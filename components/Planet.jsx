/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 planet.gltf
*/

import React, { useRef } from 'react';
import { OrbitControls, useGLTF } from '@react-three/drei';
import * as THREE from 'three';
import { useFrame, useThree } from '@react-three/fiber';

export default React.forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF('/planet-core.gltf');
  const planetRef = useRef();
  const cameraRef = useRef();
  const mouseRef = useRef({ x: 0, y: 0 });
  const radius = 2.5;
  const phi = (90 * Math.PI) / 180;

  const { camera } = useThree();

  function lerp(prevV, newV, amt = 0.1) {
    return (1 - amt) * prevV + amt * newV;
  }

  useFrame(({ clock, viewport }) => {
    if (cameraRef.current) {
      const elapsedTime = clock.getElapsedTime() * 3;
      const theta = (elapsedTime * Math.PI) / 180;
      const x = radius * Math.cos(theta);
      const y = radius * Math.sin(theta);
      const z = 0;

      const { width, height } = viewport.getCurrentViewport(camera, [0, 0, 0]);

      //smothing the mouse position change
      const valueX = lerp(mouseRef.current.x, ref.current.mouseTrack.x);
      const valueY = lerp(mouseRef.current.y, ref.current.mouseTrack.y);

      mouseRef.current = { x: valueX, y: valueY };

      //calculate the mouse position relative to the current viewport width and height
      const mouseX = (valueX / (width * 170)) * 2 - 1; //#why 170 factor? idk, it works
      const mouseY = (valueY / (height * 170)) * 2 - 1;

      //calculate the angle of the camera target relative to the mouse position
      const angleX = theta - Math.PI / (3 + mouseX); //in radians
      const angleY = phi - Math.PI / (3 - mouseY); //in radians #this value is correct?

      //calculate the position of the target of the camera relative to the angles
      const xT = radius * 1.5 * Math.cos(angleX);
      const yT = radius * 1.5 * Math.sin(angleX);
      const zT = Math.sin(angleY);

      //setting the camera position and target to simulate a planetary orbit
      camera.position.set(x, z, y);
      cameraRef.current.target = new THREE.Vector3(xT, zT, yT);
    }
  });

  return (
    <group ref={planetRef} position={[0, 0, 0]} scale={2} dispose={null}>
      <OrbitControls
        enableDamping={false}
        enableRotate={false}
        enableZoom={false}
        enablePan={false}
        ref={cameraRef}
      />
      <mesh geometry={nodes.Sphere.geometry}>
        <meshStandardMaterial
          map={materials['Material.001'].map}
          normalMap={materials['Material.001'].normalMap}
          normalScale={materials['Material.001'].normalScale}
          normalMap-encoding={THREE.LinearEncoding}
        />
      </mesh>
      <mesh
        scale={1.015}
        geometry={nodes.Sphere001.geometry}
        material={materials['Material.002']}
      />
    </group>
  );
});

useGLTF.preload('/planet-core.gltf');
