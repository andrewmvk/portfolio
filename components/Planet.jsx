/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 planet.gltf
*/

import React, { useRef } from 'react';
import { OrbitControls, useGLTF } from '@react-three/drei';
import * as THREE from 'three';
import { useFrame, useThree } from '@react-three/fiber';

export default React.forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF('/planet-core.gltf');
  const planetRef = useRef();
  const cameraRef = useRef();
  const mouseRef = useRef({ x: 0, y: 0 });
  const radius = 2.5;
  const phi = (90 * Math.PI) / 180;

  const { camera } = useThree();

  function lerp(prevV, newV, amt = 0.1) {
    return (1 - amt) * prevV + amt * newV;
  }

  useFrame(({ clock }) => {
    if (cameraRef.current) {
      const elapsedTime = clock.getElapsedTime() * 3;
      const theta = (elapsedTime * Math.PI) / 180;
      const x = radius * Math.cos(theta);
      const z = radius * Math.sin(theta);
      const y = 0;

      //Smothing the mouse position change
      const valueX = lerp(mouseRef.current.x, ref.current.mouseTrack.x);
      const valueY = lerp(mouseRef.current.y, ref.current.mouseTrack.y);

      mouseRef.current = { x: valueX, y: valueY };

      //Calculate the mouse position relative to the current viewport width and height
      const mouseX = (valueX / window.innerWidth) * 2 - 1;
      const mouseY = (valueY / window.innerHeight) * 2 - 1;

      //Calculate the angle of the camera target relative to the mouse position
      const angleX = theta - Math.PI / (2 + mouseX / 2); //in radians
      const angleY = phi - Math.PI / (2 - mouseY); //in radians #this value is correct?

      //Calculate the position of the target of the camera relative to the angles
      //It's like a another circle that is 100 times larger than the circle than the camera is following
      const xT = radius * 100 * Math.cos(angleX);
      const zT = radius * 100 * Math.sin(angleX);
      const yT = radius * 100 * Math.sin(angleY);

      //setting the camera position and target to simulate a planetary orbit
      camera.position.set(x, y, z);
      const lookingAtPosition = ref.current.cameraSettings.lookingAt;
      console.log(cameraRef.current.target);
      if (lookingAtPosition) {
        const xL = lerp(cameraRef.current.target.x, lookingAtPosition.x, 0.01);
        const yL = lerp(cameraRef.current.target.y, lookingAtPosition.y, 0.01);
        const zL = lerp(cameraRef.current.target.z, lookingAtPosition.z, 0.01);
        cameraRef.current.target = new THREE.Vector3(xL, yL, zL);
        // camera.zoom = lerp(camera.zoom, 5);
        // camera.fov = lerp(camera.fov, 50, 0.01);
      } else {
        cameraRef.current.target = new THREE.Vector3(xT, yT, zT);
      }
    }
  });

  return (
    <group ref={planetRef} position={[0, 0, 0]} scale={2} dispose={null}>
      <OrbitControls
        enableDamping={false}
        enableRotate={false}
        enableZoom={false}
        enablePan={false}
        ref={cameraRef}
      />
      <mesh geometry={nodes.Sphere.geometry}>
        <meshStandardMaterial
          map={materials['Material.001'].map}
          normalMap={materials['Material.001'].normalMap}
          normalScale={materials['Material.001'].normalScale}
          normalMap-encoding={THREE.LinearEncoding}
        />
      </mesh>
      <mesh
        scale={1.015}
        geometry={nodes.Sphere001.geometry}
        material={materials['Material.002']}
      />
    </group>
  );
});

useGLTF.preload('/planet-core.gltf');
